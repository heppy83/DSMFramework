 /**
 * The Server Side Engine in charge to actually run the process and connect to services through adapters. 
 * A client side engine is also present that starts the execution an allows the interaction with possible UI components in the browser. 
 */

//  Components are objects of this form:
// 
//function Component (id, name, binding, type, endpoint, reference, configurationParameters, operations, viewport, componentObject){
//	this.id = id;
//	this.name = name;
//	this.type = type;
//	this.endpoint= endpoint;
//	this.reference= reference;
//	this.bining = binding;
//	this.configurationParameters = configurationParameters;
//	this.operations = operations;
//	this.viewport = viewport;
//	this.instance = componentObject;
//}

var $ = require("jquery"),
	JSAdapter = require("JSAdapterSS.js"),
	http = require("http"),
	CMPUtils = require("CMPUtils.js");
    XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;


// this is needed to use JQuery ajax calls
$.support.cors = true;
$.ajaxSettings.xhr = function () {
    return new XMLHttpRequest;
}

var createSsEngineInstance = function(engineInstId, compositionURL){
	return new Engine(engineInstId, compositionURL);
}

var Engine = function(engineInstId, compositionURL){
	
	var engineInstanceId = engineInstId;
	
	// invocation counter is used as correlation ID for operation invocation->responses, since reponses are asynch and can arrive in a different order wrt to associated invocations
	var invocationCounter =0;
	
	this.webSocketServer = undefined; // this is set by the dispatcher after SS Engine creation

	// TODO: at the moment we are managing only single page / single user mashups. in the future we will need an array of WSSs, one item for each page/user
	this.webSocketClient = undefined;
	
	this.componentArray = new Object();
	this.composition = new Object();
	
	this.joins = new Object();
	this.splits = new Object();
	
	this.paradigm = "";
	this.dataReferencesMode = "";
	
	this.compositionURL = compositionURL;
	
	this.DATA_FLOW = "data_flow";
	this.CONTROL_FLOW = "control_flow";
	
	this.REFERENCE = "reference"; // Used to require a service to return only the reference to the data
	this.DATA = "data"; // Used to get from a service only the actual data. This mode is used only with services which do not understand the Reference Transferring Mode.
	this.NO_SUPPORT = "no_reference_mode_support"; // Used to state that a component does not support the reference passing mode.
	
	// used in case of non-UI flow-starting components. contains the IDs of the operations to be fed and invoked to run the mashup  
	this.startingOperationsArray = [];
	// used in case of non-UI flow-ending components. contains the output of the last operation constituting the mashup final output
	this.finalOutput = [];
	
	// contains the global variable defined in the mashup, in the form: [{globalVarId: {type: reference|data, value: globalVarValue}}]
	this.globalVariables = new Object();
	
	// object used to buffer the input pars of operations since they may not come altogether (i.e., with Dataflow or Blackboard, when they are connected to different operations)  
	this.inputBuffers = new Object();
	
	if (!Object.keys) {
	    Object.keys = function (obj) {
	        var keys = [],
	            k;
	        for (k in obj) {
	            if (Object.prototype.hasOwnProperty.call(obj, k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	}


	this.setWebSocketServer = function (wss) {
		this.webSocketServer = wss;
		
		var onWSSConnectionResponse = function(ws){ 
			console.log("\nClient side engine connected!"); 
			
			this.webSocketClient = ws;
			this.webSocketClient.send('{"type": "socket_connection_ok", "body": {}}');
			
			var onWSCMessage = function(event){ 
				//console.log("\nnew message from the client - webSocketClient");
				this.dispatchIncomingMessage(JSON.parse(event));
			}
			
			this.webSocketClient.on('message', onWSCMessage.bind(this));
		}
		
		this.webSocketServer.on('connection', onWSSConnectionResponse.bind(this));
	};
	
	this.dispatchIncomingMessage = function(message){
		if (message.type == "request-response" || message.type == "notification"){
			this.notification(message.body.correlationId,message.body.operationRef, message.body.params)
		}
		else if(message.type == "start_no_ui_flows"){
			var comp = this.componentArray[message.body.componentId];
			
			this.invokeOperation(comp, message.body.operationId, message.body.inputParams, message.body.requestDataTransferringMode, message.body.responseDataTransferringMode);
		}
			
	};
	
	this.setParadigm = function (paradigm) {
		this.paradigm = paradigm;
	};
	
	this.setDataReferencesMode = function (flag) {
		this.dataReferencesMode = flag;
	};
	
	this.processComposition = function (compos){
		this.composition = $("mashup",compos);
		components = $("component", this.composition);
		
		var compArr = new Object();
		$.each(components, // parse component XML def in JS object of the form:
						   // {'id': id, 'name': name, 'type': type, 'reference': reference, 'inputs': inputsArray, 'outputs': outputsArray}
						function (key, currComp){
							var id = $(currComp).attr("id");
							var name = $(currComp).attr("name");
							var type = $(currComp).attr("type");
							var endpoint= $(currComp).attr("endpoint");
							//TODO: add the comp reference to the composition model
							var componentReference= $(currComp).attr("reference");
							var binding = $(currComp).attr("binding");
							var viewport = type=="ui" ? $("viewport displays_component[ref="+ id +"]", $(this).closest("mashup")).parent().attr("name") : null;
							var supportReferencePassing = $(currComp).attr("supportReferencePassing") == "yes" ? true : false;
							
							var configParamsArray = new Object;
							var configParams = $(currComp).find("configurationParameter");
							$.each(configParams, function(key, param){
								var id = $(param).attr("id");
								var name = $(param).attr("name");
								var manualInput = $(param).attr("manualInput");
								var dataType = $(param).find("has_dataType").attr("ref");
								var value = $("constant feeds_configurationParameter[ref="+ id +"]", $(this).closest("mashup")).parent().attr("value");
								
								configParamsArray[id]={'id': id, 'name': name, 'manualInput': manualInput, 'dataType': dataType, 'value': value};
							});
							
							var operationsArray = new Object();
							var operations = $(currComp).find("operation");
							$.each(operations, function(key, oper){
								var id = $(oper).attr("id");
								var name = $(oper).attr("name");
								var type = $(oper).attr("type");
								var reference = $(oper).attr("reference");
								
								var inputsArray = new Object;
								var inputs = $(oper).find("inputParameter");
								$.each(inputs, function(key, input){
									var id = $(input).attr("id");
									var name = $(input).attr("name");
									var dataType = $(input).find("has_dataType").attr("ref");
									var manualInput = $(input).attr("manualInput");
									var optional= $(input).attr("optional");
									
									inputsArray[id]={'name': name, 'dataType': dataType, 'manualInput': manualInput, 'optional': optional};
								});
								
								var outputsArray = new Object();
								var outputs = $(oper).find("outputParameter");
								$.each(outputs, function(key, output){
									var id = $(output).attr("id");
									var name = $(output).attr("name");
									var dataType = $(output).find("has_dataType").attr("ref");
									
									outputsArray[id]={'name': name, 'dataType': dataType};
								});
								
								operationsArray[id]={'name': name, 'type': type, 'reference': reference, 'inputs': inputsArray, 'outputs': outputsArray};
							});
							
							compArr[id]={'name': name, 'type': type, 'endpoint': endpoint, 'reference': componentReference, 'binding': binding, 'supportReferencePassing': supportReferencePassing, 'configurationParameters': configParamsArray, 'operations': operationsArray, 'viewport':viewport, 'instance': null};
						});
		
		this.componentArray = compArr;
		
		var gv = $("globalVariable", this.composition);
		var globalVars = new Object();
		var DATA = this.DATA;
		$.each(gv, // parse XML def in JS object of the form:
						   // [{globalVarId: {globalVarType, globalVarValue}}]
						function (key, currGV){
							var gvId = $(currGV).attr("id");
							var gvDefaultValue = $(currGV).attr("defaultValue");
							globalVars[gvId] = new Object();
							globalVars[gvId].type = DATA;
							globalVars[gvId].value = gvDefaultValue;
		});
		
		this.globalVariables = globalVars;
		
		var j = $("join", this.composition);
		var joins = new Object();
		var DATA = this.DATA;
		$.each(j, // parse XML def in JS object of the form:
						   // [{joinId: {sources: [{sourceOperId: true/false}], target: targetOperId} }]
						function (key, currJoin){
							var joinId = $(currJoin).attr("id");
							
							var src = $("source_operation", currJoin);
							var sources = new Object();
							$.each(src, function(key, currSrc){
								var srcId = $(currSrc).attr("ref");
								sources[srcId] = false;
							});
							
							var targetId = $($("target_operation", currJoin)[0]).attr("ref");
							
							joins[joinId] = new Object();
							joins[joinId].sources = sources;
							joins[joinId].target = targetId;
		});
		this.joins = joins;
		
		var s = $("split", this.composition);
		var splits = new Object();
		var DATA = this.DATA;
		$.each(s, // parse XML def in JS object of the form:
						   // [{splitId: {targets: [{targetOperId: true/false}], source: sourceOperId} }]
						function (key, currSplit){
							var splitId = $(currSplit).attr("id");
							
							var tgt = $("target_operation", currSplit);
							var targets = new Object();
							$.each(tgt, function(key, currTgt){
								var tgtId = $(currTgt).attr("ref");
								targets[tgtId] = false;
							})
							
							var sourceId = $($("source_operation", currSplit)[0]).attr("ref");
							
							splits[splitId] = new Object();
							splits[splitId].source = sourceId;
							splits[splitId].targets = targets;
		});
		this.splits = splits;
	}
	
	this.parseCompositionXML = function (compositionURL) {

		
		/*
		var compos;
		$.ajax({
		    url : compositionURL,
		    dataType : 'text/xml',
		    success: function(data, status){
		    	compos = data;
		    },
			async: false
		});
		*/
		
		var onGetReponse = function(res) {
			console.log("\nGot response: " + res.statusCode);
			var response = "";
			res.on('data', function(chunk){
		        //console.log("\nINFO: "+chunk);
		        response += chunk;
		    });

			var	onEnd = function(){
		        //console.log("\nEnd received!");
		        var compos = CMPUtils.stringToXML(response);
		        this.processComposition(compos);
		        console.log("\nRunning composition definition: \""+ this.composition.attr("name") +"\"")
		        this.getPlatformConfiguration(this.composition);
		    };
				    
		    // This never happens
		    res.on('end', onEnd.bind(this));
		    
		    res.on('error', function(e) {
				  console.log("\nGot error: " + e.message);
		    });
		};
		
		http.get(compositionURL, onGetReponse.bind(this));
	};
	this.parseCompositionXML(this.compositionURL);
	
	
	this.getPlatformConfiguration = function (composition) {
		
		var configPackURL = composition.attr("configurationPackageURL")
		console.log("    Using platform configuration package: \""+ configPackURL +"\"")
		
		var onGetReponse = function(res) {
			//console.log("\nGot response: " + res.statusCode);
			var response = "";
			res.on('data', function(chunk){
		        //console.log("\nINFO: "+chunk);
		        response += chunk;
		    });

			var	onEnd = function(){
		        //console.log("\nEnd received!");
		        var config = CMPUtils.stringToXML(response);
		        this.platformConfiguration = $("configuration", config);
		        
		        // setting the paradigm (control or data flow)
		    	if($("feature[name=data_flow]", this.platformConfiguration).length>0)
		    		this.paradigm = this.DATA_FLOW; 
		    	else if($("feature[name=control_flow]", this.platformConfiguration).length>0)
		    		this.paradigm = this.CONTROL_FLOW;

		    	// setting whether the data passing by reference is  
		    	this.dataReferencesMode = ($("feature[name=support_reference_passing]", this.platformConfiguration).length>0) ? true : false;
		    };
				    
		    // This never happens
		    res.on('end', onEnd.bind(this));
		    
		    res.on('error', function(e) {
				  console.log("\nGot error: " + e.message);
		    });
		};
		
		http.get(configPackURL+"/configuration.xml", onGetReponse.bind(this));
	}
	
	this.checkCondition = function (lang, condition, outputData) {
		if(lang=="javascript"){
			
			// output parameters data can be used both in CONTROL_FLOW and in DATA_FLOW
			// TODO: do we need this for control flow?! or we say that only glob variables data can be used!? in this case in runCFComp we dont need responseOutputs 
			for(var o in outputData){
				var outputName =  $("outputParameter[id="+ o +"]", this.composition).attr("name");
				eval('var ' + outputName +'='+outputData[o]);
			}
			
			// global variables data can be used only in CONTROL_FLOW, when global variables are present
			for(var gv in this.globalVariables){
				if(this.globalVariables[gv].value != "" && this.globalVariables[gv].value != undefined){
					var gvName =  $("globalVariable[id="+ gv +"]", this.composition).attr("name");
					eval('var ' + gvName +'='+ this.globalVariables[gv].value);
				}
			}
			
			try{
				return eval('('+condition+')');
			} catch (e){
				console.log("\nERR: Bad condition definition. Connector ignored. Details: " + e.message);
	    		return false;
			}
		}
		//else if(lang=="XXX")
		else{
			// TODO: should we ignore the connector or just the condition (i.e., return TRUE)??
			console.log("\nERR: Unknown condition definition language '"+ lang +"' for condition '"+ condition +"'. The connector will be ignored.");
			return false;
		}
	};
	
	this.runCFComposition = function (completedOperation, responseOutputs) {
	
		var requestDataTransferringMode = null;
		var responseDataTransferringMode = null;
		
		var invokeTargetOper = function(targetOperId){
			
			var targetComp = this.componentArray[$("operation[id="+ targetOperId +"]", this.composition).parents("component").attr("id")];
			
			// check for all the inputs if there is a global variable or a constant attached and use its value to feed the operation params
			var targetInputParams = new Object();
			for(tip in targetComp.operations[targetOperId].inputs){
				var srcGlobalVarId = $("dfConnector target_inputParameter[ref="+ tip +"]",this.composition) != null ? $("dfConnector target_inputParameter[ref="+ tip +"]",this.composition).parent().children("source_globalVariable").attr("ref") : undefined;
				if(srcGlobalVarId != undefined){
					targetInputParams[tip] = this.globalVariables[srcGlobalVarId].value;
					requestDataTransferringMode = this.globalVariables[srcGlobalVarId].type; // by design, ALL the variables feeding ther taget oper's inputs will contain the same type of value (data/refs)
				}
				else if(targetComp.operations[targetOperId].inputs[tip].manualInput=="yes" && $("constant feeds_inputParameter[ref="+ tip +"]",this.composition).length>0)
					targetInputParams[tip]= $("constant feeds_inputParameter[ref="+ tip +"]",this.composition).parent().attr("value");
			}

			if(this.dataReferencesMode==true){
				// compute responseDataTransferringMode: check for all var where the op outputs will be written if all the operations reading from those vars supports data or reference mode. 
				// in addition check if some of them get manual inputs (i.e., data mode is needed although the operation supports reference)
				var doReadingCompsSupportRef = true;
				for(sop in targetComp.operations[targetOperId].outputs){
					var trgtGlobalVars = $("dfConnector source_outputParameter[ref="+ sop +"]",this.composition).parent().children("target_globalVariable");
					
					var checkNextVar = function(index, globalVar){ // check all the operations reading from these vars, if they support data or reference mode and if they use manual inputs
						var trgtInputParamsReadingFromCurrVar = $("dfConnector source_globalVariable[ref="+ $(globalVar).attr("id") +"]",this.composition).parent().children("target_inputParameter");
						
						var checkNextComp =  function(index, tgrtInPar){
							var readingCompId = $("inputParameter[id="+ $(tgrtInPar).attr("ref") +"]",this.composition).parent("component").attr("id");
							var readingCompManualInputs = $("component[id="+ readingCompId +"] inputParameter[manualInput=yes]" , this.composition);
							if(this.componentArray[readingCompId].supportReferencePassing == false || $(readingCompManualInputs).length>0)
								doReadingCompsSupportRef = false; 
						};
						
						$.each(trgtInputParamsReadingFromCurrVar, checkNextComp.bind(this));
					};
					
					$.each(trgtGlobalVars, checkNextVar.bind(this));
				}
				responseDataTransferringMode = doReadingCompsSupportRef==true ? this.REFERENCE : this.DATA;
			} else
				responseDataTransferringMode = this.NO_SUPPORT;
			
			this.invokeOperation(targetComp, targetOperId, targetInputParams, requestDataTransferringMode, responseDataTransferringMode);
		};
		
		
		if($("join source_operation[ref="+ completedOperation +"]", this.composition).length>0){
			var joins = $("join source_operation[ref="+ completedOperation +"]", this.composition).parent();
			var joinsIds = new Array();
			$.each(joins, function(index, currJoin){joinsIds.push($(currJoin).attr("id"));});
			
			// for each attached join
			for(var j=0; j<joinsIds.length; j++){
			
				this.joins[joinsIds[j]].sources[completedOperation] = true;
				
				var allSourceOpersReady = true;

				// if all sources opers of the current join have been activated (ie, are true), invoke target oper
				for(var src in this.joins[joinsIds[j]].sources){
					if (this.joins[joinsIds[j]].sources[src] == false)
						allSourceOpersReady = false;
				}
				
				if (allSourceOpersReady){
					
					// reset the join to wait possible new operations to synch
					for(var src in this.joins[joinsIds[j]].sources)
						this.joins[joinsIds[j]].sources[src] = false;
					
					//check if there is an associated condition and test it
					var condTag = $("split[id="+ joinsIds[j] +"]", this.composition).children("condition").first();
					var checkCond = condTag.length>0 ? this.checkCondition(condTag.attr("language"), condTag.text(), responseOutputs) : true;
					
					if( checkCond ){
						var targetOperId = this.joins[joinsIds[j]].target;
						// invoke the target operation
						invokeTargetOper.call(this, targetOperId);
					}
				}
			}
		}
		else
		if($("split source_operation[ref="+ completedOperation +"]", this.composition).length>0){
			var splits = $("split source_operation[ref="+ completedOperation +"]", this.composition).parent();
			var splitsIds = new Array();
			$.each(splits, function(index, currSplit){splitsIds.push($(currSplit).attr("id"));});
			
			// for each attached join
			for(var s=0; s<splitsIds.length; s++){
				//check if there is an associated condition and test it
				var condTag = $("split[id="+ splitsIds[s] +"]", this.composition).children("condition").first();
				var checkCond = condTag.length>0 ? this.checkCondition(condTag.attr("language"), condTag.text(), responseOutputs) : true;
				
				if( checkCond ){
					// for each target operation
					for(var tgt in this.splits[splitsIds[s]].targets){
						var targetOperId = tgt;
						// invoke the target operation
						invokeTargetOper.call(this, targetOperId);
					}
				}
			}
		}
		else
		if($("cfConnector source_operation[ref="+ completedOperation +"]", this.composition).length>0){
			// the -possibly many- target operations(s) of the connector(s) attached to the just completed operation
			var targetOpers = $("cfConnector source_operation[ref="+ completedOperation +"]", this.composition).parent("cfConnector").children("target_operation");
			var targetOperIds = new Array();
			$.each(targetOpers, function(index, value){targetOperIds.push($(value).attr("ref"));});
			
			// for each target operation (i.e., cf connector)
			for(var to=0; to<targetOperIds.length; to++){
				var condTag = $("cfConnector", this.composition).filter(function (index) {
	                  return $(this).children("source_operation[ref="+ completedOperation +"]") && $(this).children("target_operation[ref="+ targetOperIds[to] +"]");})
	                  .children("condition").first();
				var checkCond = condTag.length>0 ? this.checkCondition(condTag.attr("language"), condTag.text(), responseOutputs) : true;
				
				if( checkCond ){
					var targetOperId = targetOperIds[to];
					// invoke the target operation
					invokeTargetOper.call(this, targetOperId);
				}
			}
		}
		else{
			this.finalOutput.push(responseOutputs);
			console.log("\nFinal output reached = " + CMPUtils.JSONToString(this.finalOutput));
		}
	};
	
	this.runDFComposition = function (responseOutputs, requestDataTransferringMode) {
		
	    	for(o in responseOutputs){
				if($("dfConnector source_outputParameter[ref="+ o +"]", this.composition).length>0){
					// the -possibly many- target input parameter(s) of the connector(s) attached to the current output of the last operation invoked
					var targetInputParams = $("dfConnector source_outputParameter[ref="+ o +"]", this.composition).parent("dfConnector").children("target_inputParameter");
					var targetInputParamIds = new Array();
					$.each(targetInputParams, function(index, value){targetInputParamIds.push($(value).attr("ref"));});
					
					
					for(a=0; a<targetInputParamIds.length; a++){
						
						var condTag = $("dfConnector", this.composition).filter(function (index) {
			                  return $(this).children("source_outputParameter[ref="+ o +"]") && $(this).children("target_inputParameter[ref="+ targetInputParamIds[a] +"]");})
			                  .children("condition").first();
						var checkCond = condTag.length>0 ? this.checkCondition(condTag.attr("language"), condTag.text(), responseOutputs) : true;
	
						if( checkCond ){
							var targetComp = this.componentArray[$("inputParameter[id="+ targetInputParamIds[a] +"]", this.composition).parents("component").attr("id")];
							var targetOperId = $("inputParameter[id="+ targetInputParamIds[a] +"]", this.composition).parent("operation").attr("id");
							
							var targetInputParams = new Object();
							for(tip in targetComp.operations[targetOperId].inputs){
								if(tip==targetInputParamIds[a])
									targetInputParams[tip]= responseOutputs[o];
								else if(targetComp.operations[targetOperId].inputs[tip].manualInput=="yes" && $("constant feeds_inputParameter[ref="+ tip +"]",this.composition).length>0)
									targetInputParams[tip]= $("constant feeds_inputParameter[ref="+ tip +"]",this.composition).parent().attr("value");
							}
							
						/*  
						 * when the feature support_reference_passing is selected the default data passing mode is by reference
						 * however it must be checked whether the comps connected to the output params of the oper being invoked do support the reference mode or not. 
						 * if at least one of them does not, actual data must be required as response of the operation being invoked 
						*/ 
							var responseDataTransferringMode;
							if(this.dataReferencesMode==true){
						 		var doesNextComponentRequireData = false;
						 		
						 		for(var targetOutputParam in targetComp.operations[targetOperId].outputs){
							 		if($("dfConnector source_outputParameter[ref="+ targetOutputParam +"]", this.composition).length>0){
										// the -possibly many- target input paramter(s) of the connector(s) attached to the current output of the next operation being invoked
										var nextInputParams = $("dfConnector source_outputParameter[ref="+ targetOutputParam +"]", this.composition).parent("dfConnector").children("target_inputParameter");
										
										var checkNextComp = function(index, nextInputPar){
											var nextComp = this.componentArray[$("inputParameter[id="+ $(nextInputPar).attr("ref") +"]", this.composition).parents("component").attr("id")];
											if(nextComp.supportReferencePassing==false)
												doesNextComponentRequireData=true;
										};
										
										$.each(nextInputParams, checkNextComp.bind(this));
							 		}
						 		}
						 		responseDataTransferringMode = doesNextComponentRequireData==true ? this.DATA : this.REFERENCE;
						 	}
							else
								responseDataTransferringMode = this.NO_SUPPORT;
							
							this.invokeOperation(targetComp, targetOperId, targetInputParams, requestDataTransferringMode, responseDataTransferringMode);
						}
					}
				}
				else{
					this.finalOutput.push(responseOutputs);
					console.log("\nFinal output reached = " + CMPUtils.JSONToString(this.finalOutput));
				}
			}
	};
	
	// invoke(componentObject, operationId, inputParametersAssociativeArray, requestDataTransferringMode, responseDataTransferringMode)
	this.invokeOperation = function(component, operationId, inputParams, requestDataTransferringMode, responseDataTransferringMode){
	
		invocationCounter++;
		var t = this;
		var ctx = {'engine':t, 'component':component, 'operationId':operationId}; //, 'inputParams':inputParams, 'configParams':configParams};
		
		var allInputsReady;
		var tempBuffer;
		
		if(this.paradigm== this.CONTROL_FLOW){
			allInputsReady = true; // by definition when the flow reached the operation it is invoked. it is responsibility of the designer to make a consistent data passing
			tempBuffer = inputParams;
		}
		else if(this.paradigm == this.DATA_FLOW){
			
			// collect all the inputs for the operation being invoked, i.e., wait unitl all input params are provided (logic AND)
			var operInputs = component.operations[operationId].inputs;
			tempBuffer = t.inputBuffers[operationId]==undefined ? new Object() : t.inputBuffers[operationId];
			
			// for all the expected inputs: 
			//    if a value for a given input is already present in the buffer, keep it and do not replace with a possible new value.
			//    ow, take the value for the input from "inputParams"
			for(ins in operInputs){
				if(tempBuffer[ins] == undefined){
					if(inputParams[ins] != undefined)
						tempBuffer[ins] = inputParams[ins];
				}
			}
			
			// TODO: here we should exclude the inputs marked as optional
			allInputsReady = Object.keys(tempBuffer).length<Object.keys(operInputs).length?false:true;
		}
		
		//if all needed inputs are avail, invoke; ow buffering of the partial input in this.inputBuffers[operationId], to be used during next invocation
		if(allInputsReady==false)
			t.inputBuffers[operationId] = tempBuffer;
		else{
			// if all inputs are available use them to invoke the operation and clean the buffer
			delete t.inputBuffers[operationId];
			
			// build the input params list replacing IDs (which are unknown to services) with params names as defined in the component descriptor
			var params = new Object();
			for(var i in tempBuffer){
				var inputName = component.operations[operationId].inputs[i].name;
			 	params[inputName] = tempBuffer[i];
			}
		 	
		 	var outputParamNames = [];
		 	// operation's output-params-names list
		 	for(var o in component.operations[operationId].outputs){
		 		var oParamName = component.operations[operationId].outputs[o].name;
			 	outputParamNames.push(oParamName);
			}
		 	
		 	var data= new Object();
		 	data.endpoint = "";
		 	data.componentInstance = "";
		 	data.operationReference = "";
		 	data.method = "";
		 	data.parameters = params;
		 	data.expectedOutputParameterNames = outputParamNames;
		 	data.responseDataTransferringMode = responseDataTransferringMode; // responseDataTransferringMode can be either DATA or REFERENCE
		 	data.requestDataTransferringMode = requestDataTransferringMode; // requestDataTransferringMode can be either DATA or REFERENCE
						
			console.log("\nInvoking operation \""+ component.operations[operationId].name + "\" of the \""+ component.name +"\" component");
			
			if(component.binding=="REST" || component.binding=="RSS" || component.binding=="atom"){
				
				//ACCESS THE Adapter SERVICE ON THE OTHER SERVER (tomcat: http://localhost:8070/EngineAdapters/adapters/REST)
				var adapterHost = "localhost", adapterPort="8070", adapterPath="/EngineAdapters/adapters/REST";
				
				//For REST components the operation reference attribute contains HTTP-METHOD and ENDPOINT-URL in the form: "method space URL", e.g., "GET http://..."
				var reference= component.operations[operationId].reference;
				data.endpoint = reference.split(" ")[1].trim();
				data.method = reference.split(" ")[0].trim();
				
				/* $.ajax not working
				$.ajax({
				    url : adapterUrl,
				    type: "POST",
				    data : JSON.stringify(data),
				    contentType: "application/json; charset=utf-8",
				    dataType : 'json',
				    cache:false,
				    context: ctx,
				    success: this.processAdaptersResponse,
				    error: function(xhr, status, errors){
				    	console.log("\nAn error occurred while invoking the adapter: " +errors);
				    },
					async: false
				}); // end Ajax call
				*/

				
				var options = {
				  hostname: adapterHost,
				  port: adapterPort,
				  path: adapterPath,
				  method: 'POST',
				  headers: {'Content-Type': "application/json"}
				};
				
				var onHttpResponse = function(res){
					var responseBody = "";
					console.log('STATUS: ' + res.statusCode);
					//console.log('HEADERS: ' + JSON.stringify(res.headers));
					res.setEncoding('utf8');
					res.on('data', function (chunk) {
						//console.log('BODY: ' + chunk);
						responseBody += chunk;
					});
					var onResponseComplete = function(){
						console.log("Reply from operation \""+ ctx.component.operations[ctx.operationId].name +"\"");
						this.processAdaptersResponse(JSON.parse(responseBody), null, null, ctx);
					}
					
					res.on('end', onResponseComplete.bind(this));
				};  
				
				var req = http.request(options, onHttpResponse.bind(this) );
				
				
				
				req.on('error', function(e) {
					console.log('problem with request: ' + e.message);
				});
				
				// write data to request body
				req.write(JSON.stringify(data));
				req.end();
				
				//console.log(http.ClientResponse);
				
			}
			else if(component.binding=="SOAP"){
				
				// TODO: TO BE FIXED (like in teh REST case above) TO ACCESS THE SERVICE ON THE OTHER SERVER (tomcat: http://localhost:8080/EngineAdapters/adapters/SOAP)
				var adapterUrl = "http://localhost:8070/EngineAdapters/adapters/SOAP";
				
				data.endpoint = component.endpoint;
				data.operationReference = component.operations[operationId].reference;
				
				$.ajax({
				    url : adapterUrl,
				    type: "POST",
				    data : $.toJSON(data),
				    contentType: "application/json; charset=utf-8",
				    dataType : 'json',
				    cache: false,
				    context: ctx,
				    success: this.processAdaptersResponse,
				    error: function(xhr, status, errors){
				    	console.log("\nERR: " +errors);
				    	alert("An error occurred while invoking the adapter");
				    },
					async: false
				}); // end Ajax call
			}
			else if(component.binding=="javascript"){
				/*data.componentInstance = component.instance;
				data.operationReference = component.operations[operationId].reference;
				
				var response = JSAdapter.invoke(data.componentInstance, data.operationReference, data.parameters, data.expectedOutputParameterNames);*/
				
				data.componentId = getComponentId.call(this, component);
				data.webSocketRef = this.webSocketClient;
				data.operationId = operationId;
				
				/*var response = JSAdapter.invoke(data.webSocketRef, data.componentId, data.operationReference, data.parameters, data.expectedOutputParameterNames);
				
				this.processAdaptersResponse(response, null, null, ctx);*/
				
				// the possible response will be sent back to the webSocketServer and managed by the Engine.notification()
				JSAdapter.invoke(data.webSocketRef, data.componentId, data.operationId, data.parameters, data.expectedOutputParameterNames);
			}
		
		} // end ELSE (allInputsReady)
		
	};

	this.processAdaptersResponse = function(res, status, XHR, context){
		// the function parameter 'context' will be used (will be not undefined) only when invoking a JavaScript object, otherwise
		// the function processAdaptersResponse will be invoked by the ajax JQuery function putting as function context (this) the object ctx (set in the ajax properties)
		if(context == undefined)
			context = $(this)[0];
		
		
		if( context.component.operations[context.operationId].type=="request-response" || 
			context.component.operations[context.operationId].type=="notification"){ 
	    	if(res != null && res.response != null){
		    	if(res.response._adapter_error == undefined){
			    	var responseOutputs = new Object();
			    	if(typeof res.response == 'object'){
						// replace params names in the output params list with the params IDs
						for(outputName in res.response){
							var outputId = $("operation[id="+ context.operationId +"]", context.engine.composition).find("outputParameter[name="+ outputName +"]").attr("id");
							responseOutputs[outputId] = res.response[outputName];
						}
			    	}
			    	if(context.engine.paradigm == this.DATA_FLOW)
			    		context.engine.runDFComposition(responseOutputs, res.responseDataTransferringMode);
			    	else if(context.engine.paradigm == this.CONTROL_FLOW){  // if in control flow paradigm, save output params in corresponding variables and then invoke runCFComposition
			    		// check for all the outputs if there is a global variable attached and set its value with the corresponding responseOutputs value
						for(var sop in responseOutputs){
							var targetGlobalVarId = $("dfConnector source_outputParameter[ref="+ sop +"]",context.engine.composition) != null ? $("dfConnector source_outputParameter[ref="+ sop +"]",context.engine.composition).parent().children("target_globalVariable").first().attr("ref") : undefined;
							if(targetGlobalVarId != undefined){
								context.engine.globalVariables[targetGlobalVarId].type = res.responseDataTransferringMode;
								context.engine.globalVariables[targetGlobalVarId].value = responseOutputs[sop];
							}
						}
						context.engine.runCFComposition(context.operationId, responseOutputs);
			    	}
				}
		    	else{
		    		console.log("\nAn error occured during operation invocation: " + res.response._adapter_error.type +".\nDetails: "+ res.response._adapter_error.details);
		    	}
	    	}
	    	else{
	    		if(res == null){
	    			console.log("\nInternal error in the adapter");
	    		}
	    		else if(res.response == null){
	    			console.log("\nNo or empty response from a request-response operation");
	    		}
	    	}
		}
	};
	
	this.notification = function(correlationId, operationRef, params){
		var compId = correlationId.substring(0,correlationId.lastIndexOf("_"));
		var comp = this.componentArray[compId];
		var operId = $("component[id="+ compId +"] operation[reference="+ operationRef +"]", this.composition).attr("id");
		
		var outputParamNames = [];
	 	// operation's output params names list
	 	for(var o in comp.operations[operId].outputs){
	 		var oParamName = comp.operations[operId].outputs[o].name;
		 	outputParamNames.push(oParamName);
		}
		
		
		if(comp.binding == "javascript"){
			var response = JSAdapter.processIncomingMessage(params, outputParamNames);
			var t= this;
			var ctx = {'engine':t, 'component':comp, 'operationId':operId};
			this.processAdaptersResponse(response, null, null, ctx);
		}
		else if(comp.binding == "REST"){ // IS THIS POSSIBLE? Notification for REST?!
			// TODO: call REST adapter
		}
		else if(comp.binding == "SOAP"){
			// TODO: call soap adapter
		}
	};
	
	var getComponentId = function(componentObj){
		for(cId in this.componentArray){
			if(this.componentArray[cId] === componentObj)
				return cId;
		}
		
		return null; 
	}
	

}
module.exports = createSsEngineInstance;